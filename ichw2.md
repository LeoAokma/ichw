<h1> 图灵停机问题 </h1>
<h6>图灵停机问题的本质是一种逻辑悖论，该问题的提出对于程序语言的不完备性进行了论证。图灵机是一个抽象的能进行指令处理的机器（相当于现代计算机的概念模型）。</h6>
<p>
在图灵停机的情境下，对于任意图灵机，其任意指令（程序）是否可以找到一个停止的路线，即一个程序是否能在有限的时间内完成。<br/>
这个问题其实引出了程序语言的不完备性，如：<br/>
  </p>
<p>
def Judge(T): <br/>
  if T == False: <br/>
    return True <br/>
  if T == True: <br/>
    loop Forever <br/>
bool T = True <br/>
T = Judge(Judge(T)) <br/>
（数学原理为反证法）<br/>
  </p>
<p>
该程序为死循环，不能再有限的时间内结束，说明程序语言在其定义的范围内具有不完备性。图灵宕机问题模型也可以简化为<br/>
“理发师模型”。计算机是基于二进制算法来处理信息和完成指令的。对此，二进制实数范围内的运算规则的研究成为了重点。<br/>
</p>
<h1>二进制补码原理</h1>
<p>
二进制的加法最容易实现，通过一个与门（进位判定）和一个异或门（非进位判定）组成一个加法计算单元。然而，若要再开<br/>
发一套减法运算法则，不仅会消耗时间，而且会增加逻辑处理单元（ALU）的体积。为此，二进制补码诞生了。在自然数/实数<br/>
域中，我们规定了两种数，0和1：<br/>
  a ∈ R<br/>
  -是一种算符，代表相反数<br/>
  a + (-a) = 0<br/>
  1/a * a = 1<br/>
这就是在实数域中对于0和1的定义。<br/>
然而，在二进制加减法中，由于我们需要统一加法和减法，使得二者可以使用同一套逻辑运算单元（即上述的双逻辑门单元），<br/>
我们需要重新定义0：<br/>
    在计算机所需要的具有2N个数的二进制定义域（以0为中心，2N为长度的邻域）中，我们创建一个一维矢量，每个二进制<br/>
  （或其相对应的十进制数）都能对应一个矢量，其中，<br/>
对于一对相反数a,b，其对应一维矢量的值为A,B，有如下关系：<br/>
  a + b = 0<br/>
  A(DEC) + B(DEC) = 2^2N<br/>
其中，我们称B是A的补码，vice versa。<br/>
补码的产生本质上是利用了矢量的方向性，把上述邻域画为一个数轴，将数轴卷曲，头尾相连，我们可以发现环状的周期性的<br/>
一个数轴。在这个环状数轴内，a,b对应的补码为A,B，则减法a-b可以等效为a+B。（向量思想，周期性可以忽略，所以最大<br/>
的那一位溢出直接舍弃）<br/>
比如，4 - 3 对应 100 - 011<br/>
3的补码为101<br/>
有 100 - 011 = 100 + 101 = 1001<br/>
舍去最高的溢出位，我们得到结果为1(BIN)，与实际运算结果相符。<br/></p>
  
<h1> IEEE754浮点数格式16位表示法：<br/></h1>
<p>
<pre>±0              <br/>* 0000000 00000000</pre>
<pre>±1.0            <br/>* 0111111 00000000</pre>
<pre>最大规范化数     <br/>1 1111110 11111111</pre>
<pre>最小规范化数     <br/>1 0000001 00000000</pre>
<pre>最小非规范化数   <br/>1 0000000 00000001</pre>
<pre>最大非规范化数   <br/>1 0000000 11111111</pre>
<pre>±∞              <br/>* 1111111 00000000</pre>
<pre>NaN             <br/>* 1111111 (非全0)</pre>
</p>
